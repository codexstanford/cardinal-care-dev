covered(C) :-
  claim.policy(C, P) &
  policy.type(P, T) &
  covered(C, P, T)

covered(C, P, kaiser_hmo) :-
  valid_insuree(C,P) &
  policy_active(C,P) &
  claim.type(C, T) &
  eligible_service(C,P,T)

valid_insuree(C,P) :-
  claim.claimant(C,CL) &
  policy.insuree(P,I) &
  same(CL, I)

policy_active(C,P) :-
  claim.claimant(C,C1) &
  policy.startdate(P, C1, P_START_DATE) & 
  policy.enddate(P,C1, P_END_DATE) & 
  claim.date(C, C_DATE) &
  %get_timestamp_from_date(P_END_DATE, P_END_STAMP) &
  %get_timestamp_from_date(P_START_DATE, P_START_STAMP) &
  %get_timestamp_from_date(C_DATE, C_DATE_STAMP) &
  %leq(P_START_STAMP, C_DATE_STAMP) &
  %leq(C_DATE_STAMP, P_END_STAMP)
  leq(P_START_DATE, C_DATE) &
  leq(C_DATE, P_END_DATE)
  % Need more here to determine valid range, but it will depend on a query so trying not to hardcode.

get_timestamp_from_date(DATE,STAMP) :-
  evaluate(parsedate(DATE),[D,M,Y]) &
  evaluate(maketimestamp(Y,M,D,1,1,1), STAMP)

% Prescriptions
eligible_service(C, P, prescription):-
  claim.type(C, prescription) &
  claim.item(C, X) &
  elligible_prescription(C, P, X)

elligible_prescription(C, P, X) :-      % QWuantity Limit and other exceptions
  prescriptions_list(List) &
  member(X, List) &
  ~prescription_exception(C, P, X) &
  prescription_cost(C, P, X)

prescription_cost(C, P, X) :-
  prescription.tier(X, T) &
  prescriptions_tier_cost(T, C)

% Using actual data format will transitition to this! 
% elligible_prescription(C, P, X) :-
%   kaiser_hmo_drugs(List) &
%   kaiser_hmo_drugs.drug_id(X, N) & % Check that there doeds exist a drug_id 
%   ~exception_prescriptions(C, P, X) &
%   prescription_cost(C, P, X) 

% % Encoding of exception:
% exception_prescriptions(C, P, X) :-
%   kaiser_hmo_drugs.note(X)
%   % distinct(List, []) % & % If any notes exist, then there is an exception. NOT A LONG TERM SOLUTION
%   % For example, will result in a user "drop down" for now. Then we can ask how many received in past X days, 
%   % but once again like with waiver, kind of similar to "changes based on prescription so wasted work may occur"

% prescription_cost(C, P, X) :-
%   kaiser_hmo_drugs.status(X, T) &
%   prescription_tier_cost(T, N) %& % numerical value to add later, should account for non-formulary by this relation failing
%   % cost_to_add(C, P, N)  % relation to add to coverage sum
  


~international(kaiser_hmo)

prescriptions_list([ibuprofen, diphenhydramine_hcl, oxycodone_hcl, tracleer, cayston]).
prescription.tier(ibuprofen, 1)
prescription.tier(diphenhydramine_hcl, 1)
prescription.tier(ocycodone_hcl, 1)
prescription.tier(cayston, 4)
prescription_tier_cost(1, 20)
prescription_tier_cost(2, 40)
prescription_tier_cost(4, 40)

lt(X,Y):-
  leq(X,Y) &
  ~same(X,Y).

gt(X,Y) :-
  ~leq(X,Y)

gte(X,Y):-
  ~lt(X, Y)




% User Input
start_date(1672563661000) 
% Jan 1 2023 %
end_date(1737450061000) 
% Jan 21 2025, dummy dates 
sf_bay_care_in_medical(150)
sf_bay_care_out_medical(0)
sf_bay_care_in_mental(150)
sf_bay_care_out_mental(30)
annual_deductible(0)
oop_max(3500)
emb_ppaca(yes)
pc_ppaca(yes)
excluded_conditions(no) % NULL?
prescriptions(yes) 
% Needs data available at kp.og/formulary
prescriptions_tier1_mail(20)
prescriptions_tier2_mail(80)

prescription_tier_cost(1, 10)
prescription_tier_cost(2, 40)
prescription_tier_cost(4, 40)

emergency_room_cost(200)
emergency_transport_cost(50)
provider_urgent_care_cost(30)
outside_urgent_care_cost(NULL)
aggregate_max_benefit_num(NULL) 
% unsure if truly is no max

sep_first(1725177661000)
aug_end(1754035261000)
academic_year_workaround(yes) % For Sierra checks wih getyear

